/**
 * 
 * @authors yutent (yutent@doui.cc)
 * @date    2016-03-10 00:03:01
 *
 */
"use strict";

let rt = require('rethinkdb')
class baseRethink {


    constructor(conf){
        this.conf = conf
        this.log = new libs.LOG('rethink.log')
        this.promise = rt.connect(this.conf)

        this.opts = {
            durability: 'soft',
            timeFormat: 'raw'
        }
    }

    //在封装的方法不能满足需求的时候,可以使用
    then(callback){
        this.promise.then((e, conn) => {
            if(e)
                return callback(e, null)
            callback(rt, conn)
        })
    }



    /**
     * [find 查找数据]
     * @param  {Object}   conf     [查找条件、配置]
     * @param  {Function} callback [回调]
     * 范例
     * .find({
     *     db: 'test', // 要查询的库。 默认在connect时已传入,这里可自行切换。 [可选]
     *     table: 'test', // 要查的表。 [必须]
     *     where: Object, // 筛选条件,格式参照官方文档filter
     * }, function(e, result){})
     */
    find(conf, callback){
        this.promise.then(conn => {
            if(conf.hasOwnProperty('db')) //传db进来时, 切换db
                conn.use(conf.db)

            if(!conf.hasOwnProperty('where') || (typeof conf.where === 'object' && Object.empty(conf.where)))
                conf.where = {}

            let query = rt.table(conf.table).filter(conf.where)
            
            if(conf.hasOwnProperty('select') && conf.select.length > 0)
                query = query.withFields.apply(query, conf.select)

            query.run(conn, (e, cs) => {
                if(e)
                    return callback(e, null)
                cs.toArray(callback)
            })
        }).error(e => {
            this.log.error(`Find error, ${e}`)
        })
    }


    /**
     * [find 计数]
     * @param  {Object}   conf     [查找条件、配置]
     * @param  {Function} callback [回调]
     * 范例
     * .find({
     *     db: 'test', // 要查询的库。 默认在connect时已传入,这里可自行切换。 [可选]
     *     table: 'test', // 要查的表。 [必须]
     *     where: Object, // 筛选条件,格式参照官方文档filter
     * }, function(e, result){})
     */
    count(conf, callback){
        this.promise.then(conn => {
            if(conf.hasOwnProperty('db')) //传db进来时, 切换db
                conn.use(conf.db)

            if(!conf.hasOwnProperty('where') || (typeof conf.where === 'object' && Object.empty(conf.where)))
                conf.where = {}

            rt.table(conf.table).filter(conf.where).count().run(conn, callback)
        }).error(e => {
            this.log.error(`Find error, ${e}`)
        })
    }



    /**
     * [update 更新数据]
     * @param  {Object}   conf     [要插入的数据、配置]
     * @param  {Function} callback [回调]
     * 范例
     * .update({
     *     db: 'test', // 要插入的库。 默认在connect时已传入,这里可自行切换。 [可选]
     *     table: 'test', // 要查的表。 [必须]
     *     opts: {
     *         noreply: true/false, //是否需要返回插入的结果, 为真时, 性能提升近50倍, 默认为false。[可选]
     *         durability: 'soft', // hard/soft, hard更安全,但慢一些。 [可选]
     *         ... //其他配置参照官方文档
     *     },
     *     where: Object, // 筛选条件,格式参照官方文档filter
     *     $set: Object, // 要更新的字段值。 [可选]
     *     $unset: ['xx', 'oo'], //要删除的字段, 不能与$set同时使用。 [可选]
     *     update: any, //原生update方法, 当上面的$set和$unset不能满足需求时可使用这个。 [可选]
     * }, function(e, result){})
     */
    update(conf, callback){
        let opts = conf.hasOwnProperty('opts') ? Object.assign({}, this.opts, conf.opts) : this.opts
        
        this.promise.then(conn => {
            if(conf.hasOwnProperty('db')) //传db进来时, 切换db
                conn.use(conf.db)

            if(!conf.hasOwnProperty('where') || (typeof conf.where === 'object' && Object.empty(conf.where)))
                conf.where = {}

            let query = rt.table(conf.table).filter(conf.where)

            if(conf.hasOwnProperty('$unset')){
                query = query.replace(it => {
                    return it.without.apply(it, conf.$unset)
                })
            }else if(conf.hasOwnProperty('$set')){
                query = query.update(conf.$set)
            }else{
                query = query.update(conf.update)
            }
           
            query.run(conn, opts, callback)
            
        }).error(e => {
            this.log.error(`Update error, ${e}`)
        })
    }




    /**
     * [insert 插件数据]
     * @param  {Object}   conf     [要插入的数据、配置]
     * @param  {Function} callback [回调]
     * 范例
     * .insert({
     *     db: 'test', // 要插入的库。 默认在connect时已传入,这里可自行切换。 [可选]
     *     table: 'test', // 要查的表。 [必须]
     *     opts: {
     *         noreply: true/false, //是否需要返回插入的结果, 为真时, 性能提升近50倍, 默认为false。[可选]
     *         durability: 'soft', // hard/soft, hard更安全,但慢一些。 [可选]
     *         ... //其他配置参照官方文档
     *     }
     * }, function(e, result){})
     */
    insert(conf, callback){
        let opts = conf.hasOwnProperty('opts') ? Object.assign({}, this.opts, conf.opts) : this.opts

        this.promise.then(conn => {
            if(conf.hasOwnProperty('db')) //传db进来时, 切换db
                conn.use(conf.db)

            rt.table(conf.table).insert(conf.data).run(conn, opts, callback)
        }).error(e => {
            this.log.error(`Insert error, ${e}`)
        })
    }





    /**
     * [remove 删除数据]
     * @param  {Object}   conf     [要插入的数据、配置]
     * @param  {Function} callback [回调]
     * 范例:
     * .remove({
     *     db: 'test', // 要删除数据所在的库。 默认在connect时已传入,这里可自行切换。 [可选]
     *     table: 'test', // 要要删除数据所在的表。 [必须]
     *     where: Object, // 筛选条件,格式参照官方文档filter
     *     opts: {}, //参照 insert方法
     * })
     */
    remove(conf, callback){
        let opts = conf.hasOwnProperty('opts') ? Object.assign({}, this.opts, conf.opts) : this.opts
        
        this.promise.then(conn => {
            if(conf.hasOwnProperty('db')) //传db进来时, 切换db
                conn.use(conf.db)

            if(!conf.hasOwnProperty('where') || Object.empty(conf.where))
                conf.where = {}

            rt.table(conf.table).filter(conf.where).delete().run(conn, opts, callback)
        }).error(e => {
            this.log.error(`Remove error, ${e}`)
        })
    }

}



module.exports = baseRethink