/**
 * mongodb操作类
 * @authors yutent (yutent@doui.cc)
 * @date    2015-11-24 11:31:55
 *
 */
"use strict";

let mongodb = require('mongodb')
class baseMongo{

    /**
     * [constructor 构造数据库连接]
     */
    constructor(conf){
        
        this.log = new libs.LOG('mongodb.log')
        this.noop = function(){} // 空函数, 用于修正回调

        let conn = `mongodb://${conf.host}:${conf.port}/${conf.db}`
        this.promise = new Promise((resolve, reject) => {
            mongodb.MongoClient.connect(conn, (err, db) => {
                if(!err){
                    //先尝试以普通账号登录
                    db.authenticate(conf.user, conf.passwd, err => {

                        if(err){//若错误则尝试管理账号授权登录
                            db.admin().authenticate(conf.user, conf.passwd, err => {

                                if(!err){
                                    resolve(db)
                                }else{
                                    _this.log.error(`mongo authenticate failed!(-u ${conf.username} -p ${conf.passwd})`)
                                    reject(err)
                                }
                            })
                        }else{
                            resolve(db)
                        }


                    })
                }

            })
        })
    }



    /**
     * [findOne 根据条件查找一条记录]
     * @param  {[object]}   conf     [要查找的信息]
     * @param  {Function} callback [回调,返回查找结果的字段集]
     * 
     * eg.
     * .findOne({
     *     collection: '', //要查找的表 [必须]
     *     where: {}, //查找的条件, 和原生格式一致。  [必须]
     *     select: {}, //要返回的字段,同原生格式一致,默认全返回 [可选]
     * }, function(doc){...})
     */
    findOne(conf, callback){

        callback = callback || this.noop

        if(!conf.hasOwnProperty('where'))
            conf.where = {}
        
        if(conf.where.hasOwnProperty('_id') && (typeof conf.where._id == 'string'))
            conf.where._id = new mongodb.ObjectID(conf.where._id)

        if(!conf.hasOwnProperty('select') || (typeof conf.select !== 'object'))
            conf.select = {}

        this.promise.then(db => {

            db.collection(conf.collection)
                .find(conf.where, conf.select)
                .limit(1)
                .toArray((err, doc) => {
                    if(err){
                        this.log.error('findOne error, ' + err)
                        return callback(err)
                    }

                    if(!doc || doc.length < 1){
                        //返回当前查询到的文档
                        callback(err, null)
                    }else{
                        //返回当前查询到的文档
                        callback(err, doc[0])
                    }
                })

        })
    }

    /**
     * [find 查找记录,带完整功能的]
     * @param  {[object]}   conf     [要查找的信息]
     * @param  {Function} callback [回调,返回查找结果的字段集]
     * 
     * eg.
     * .find({
     *     collection: '', //要查找的表 [必须]
     *     where: {}, //查找的条件, 和原生格式一致。  [必须]
     *     select: {}, //要返回的字段,同原生格式一致,默认全返回 [可选]
     *     limit: 5, //要查找的条数,最大不超过50, 默认为1。 [可选]
     *     skip: 0, //从第几条开始找,用于分页。 [可选]
     *     sort: {}, //排序,格式和原生一样。 [可选]
     * }, function(doc){...})
     */
    find(conf, callback){

        callback = callback || this.noop

        if(conf.where.hasOwnProperty('_id') && (typeof conf.where._id == 'string'))
            conf.where._id = new mongodb.ObjectID(conf.where._id)

        if(!conf.hasOwnProperty('select') || (typeof conf.select !== 'object'))
            conf.select = {}

        if(!conf.hasOwnProperty('limit') || conf.limit < 1)
            conf.limit = 1
        else if(conf.limit > 50)
            conf.limit = 50

        if(!conf.hasOwnProperty('skip') || conf.skip < 0)
            conf.skip = 0

        if(!conf.hasOwnProperty('sort') || typeof conf.sort !== 'object')
            conf.sort = {}

        this.promise.then(db => {

            db.collection(conf.collection)
                .find(conf.where, conf.select)
                .sort(conf.sort)
                .skip(conf.skip)
                .limit(conf.limit)
                .toArray((err, docs) => {
                    if(err){
                        this.log.error('findOne error, ' + err)
                        return callback(err)
                    }

                    if(!docs || docs.length < 1){
                        //返回当前查询到的文档
                        callback(err, null)
                    }else{
                        //返回当前查询到的文档
                        callback(err, docs)
                    }
                })
        })

        
    }

    /**
     * [count 指定条件查询总数]
     * @param  {[object]}   conf     [要查找的信息]
     * @param  {Function} callback [回调,返回查找结果的总数]
     * 
     * eg.
     * .count({
     *     collection: '', //要查找的表 [必须]
     *     where: {}, //查找的条件, 和原生格式一致。 [可选]
     * }, function(num){...})
     */
    count(conf, callback){

        callback = callback || this.noop

        if(!conf.hasOwnProperty('where') || typeof conf.where !== 'object')
            conf.where = {}

        if(conf.where.hasOwnProperty('_id') && (typeof conf.where._id == 'string'))
            conf.where._id = new mongodb.ObjectID(conf.where._id)

        this.promise.then(db => {

            db.collection(conf.collection)
                .count(conf.where, (err, nums) => {
                    if(err){
                        this.log.error('count error, ' + err)
                        return callback(err)
                    }

                    //返回当前查询到的总数
                    callback(err, nums)
                })
        })

        
    }


    /**
     * [insert 插入记录,该方法允许插入重复数据(可以同时插入多条数据)]
     * @param  {[object]}   conf     [要插入的信息]
     * @param  {Function} callback [回调,返回插入的_id]
     * 
     * eg.
     * .insert({
     *     collection: '', //要插入的表 [必须]
     *     data: {}| [{}], //要插入的数据,可以是单条可以多条 [必须]
     * }, function(id){...})
     */
    insert(conf, callback){

        callback = callback || this.noop

        this.promise.then(db => {
            db.collection(conf.collection)
                .insert(conf.data, (err, res) => {
                    if(err){
                        this.log.error('insert error, ' + err)
                        return callback(err)
                    }

                    //返回插入数据的_id字段, 为一个数组
                    callback(err, res.insertedIds)
                })
        })

    }



    /**
     * [ensure 插入记录,该方法会跳过已有数据(每次只能插入一条数据)]
     * @param  {[object]}   conf     [要插入的信息]
     * @param  {Function} callback [回调,返回插入的_id]
     * 
     * eg.
     * .ensure({
     *     collection: '', //要查找的表 [必须]
     *     where: {}, //查找的条件, 和原生格式一致。 
     *     data: {}, //要插入的数据 [必须]
     * }, function(id){...})
     */
    ensure(conf, callback){

        callback = callback || this.noop

        if(!conf.hasOwnProperty('where') || typeof conf.where !== 'object')
            return this.insert(conf, callback)

        if(conf.where.hasOwnProperty('_id') && (typeof conf.where._id == 'string'))
            conf.where._id = new mongodb.ObjectID(conf.where._id)

        this.promise.then(db => {

            db.collection(conf.collection)
                .update(conf.where,
                    {$setOnInsert: conf.data},
                    {upsert: true},
                    (err, res) => {
                        if(err){
                            this.log.error('ensure error, ' + err)
                            return callback(err)
                        }
                        //返回插入数据的_id字段
                        let _id = null
                        if(res.result.hasOwnProperty('upserted'))
                            _id = res.result.upserted[0]._id

                        callback(err, _id)
                })
        })
    }



    /**
     * [update 修改记录]
     * @param  {[object]}   conf     [要查找的信息]
     * @param  {Function} callback [回调,返回查找结果的字段集]
     * 
     * eg.
     * .update({
     *     collection: '', //要查找的表 [必须]
     *     where: {}, //查找的条件, 和原生格式一致。 [必须]
     *     update: {}, //等同原生要返回的字段格式,默认会返回 [可选]
     * }, function(doc){...})
     */
    update(conf, callback){

        callback = callback || this.noop

        if(conf.where.hasOwnProperty('_id') && (typeof conf.where._id == 'string'))
            conf.where._id = new mongodb.ObjectID(conf.where._id)

        this.promise.then(db => {

            db.collection(conf.collection)
                .update(conf.where,
                    conf.update,
                    {safe: true},
                    (err, res) => {
                        if(err){
                            this.log.error('[update error], ' + err)
                            return callback(err)
                        }

                        res = JSON.parse(JSON.stringify(res))
                        //返回被修改的条数,大于0说明修改成功
                        callback(err, res.nModified)
                })
        })
            
    }



    /**
     * [remove 删除记录]
     * @param  {[object]}   conf     [要查找的信息]
     * @param  {Function} callback [回调,返回查找结果的字段集]
     * 
     * eg.
     * .remove({
     *     collection: '', //要查找的表 [必须]
     *     where: {}, //查找的条件, 和原生格式一致。 [必须]
     * }, function(doc){...})
     */
    remove(conf, callback){

        callback = callback || this.noop

        if(conf.hasOwnProperty('where') && typeof conf.where === 'object'){
            if(conf.where.hasOwnProperty('_id') && (typeof conf.where._id == 'string'))
                conf.where._id = new mongodb.ObjectID(conf.where._id)
        }else{
            return this.log.error('argument where must not be empty')
        }

        this.promise.then(db => {
            db.collection(conf.collection)
                .remove(conf.where, err => {
                    if(err){
                        this.log.error('remove error, ' + err)
                        return callback(err)
                    }

                    callback(err, true)
                })
        })
            

    }

}


module.exports = baseMongo