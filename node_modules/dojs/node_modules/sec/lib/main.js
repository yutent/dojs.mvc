/**
 * 加密类 md5/sha1/base64
 * @authors yutent (yutent@doui.cc)
 * @date    2015-09-10 13:56:18
 *
 */

"use strict";

let crypto = require('crypto')
let fs = require('fs')


/**
 * [range 生成指定范围的整数数组，包含边界值，范围没作限制]
 */
function range(start, end){
    let arr = []
    do{
        arr.push(start)
    }while(start++ < end)
    return arr
}


class Hash{
    constructor(){
        this.crypto = function(method, str, format) {
            let mSum = crypto.createHash(method)
            let isBuffer = Buffer.isBuffer(str)
            mSum.update(str, isBuffer ? 'binary' : 'utf8')
            return mSum.digest(format || 'hex')
        }
    }

    /**
     * [randStr 生成指定长度的随机字符串]
     * @param  {[type]} len      [要得到的字符串长度]
     * @param  {[type]} forceNum [是否强制返回纯数字]
     */
    randStr(len, forceNum){
        let str = 'qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM0123456789'
        if(forceNum)
            str = '0123456789'
        let max = str.length
        let tmp = ''
        for(let i = 0; i < len; i++){
            let r = Math.floor(Math.random() * max)
            tmp += str[r]
        }
        return tmp
    }

    /**
     * [md5 md5加密]
     * @param  {[type]} str    [要加密的字符串]
     * @param  {[type]} format [hex/base64]
     */
    md5(str, format){
        if(typeof str !== 'string' && typeof str !== 'number')
            return str

        return this.crypto('md5', str + '', format)
    }

    /**
     * [md5Sign 获取文件的md5签名]
     * @param  {[type]} file [文件路径]
     */
    md5Sign(file){
        if(!fs.existsSync(file))
            return

        let fileStream = fs.readFileSync(file)
        return this.crypto('md5', fileStream)
    }

    /**
     * [sha1 sha1加密]
     * @param  {[type]} str    [要加密的字符串]
     * @param  {[type]} format [hex/base64]
     */
    sha1(str, format){
        if(typeof str !== 'string' && typeof str !== 'number')
            return str

        return this.crypto('sha1', str + '', format)
    }


    /**
     * [sha1Sign 获取文件的sha1签名]
     * @param  {[type]} file [文件路径]
     */
    sha1Sign(file){
        if(!fs.existsSync(file))
            return

        let fileStream = fs.readFileSync(file)
        return this.crypto('sha1', fileStream)
    }


    /**
     * [sha256 sha256加密]
     * @param  {[type]} str    [要加密的字符串]
     * @param  {[type]} format [hex/base64]
     */
    sha256(str, format){
        if(typeof str !== 'string' && typeof str !== 'number')
            return str

        return this.crypto('sha256', str + '', format)
    }

    /**
     * [base64encode base64加密]
     * @param  {[type]} str         [要加密的字符串]
     * @param  {[type]} urlFriendly [是否对URL友好，默认否，是则会把+转成-，/转成_]
     * @return {[type]}             [加密后的字符串]
     */
    base64encode(str, urlFriendly){
        if(!Buffer.isBuffer(str))
            str = new Buffer(str)
        let encode = str.toString('base64')
        if(urlFriendly)
            encode = encode.replace(/\+/g, '-').replace(/\//g, '_')

        return encode
    }

    /**
     * [base64decode base64解密]
     * @param  {[type]} str         [要加密的字符串]
     * @param  {[type]} urlFriendly [是否对URL友好，默认否，是则会把+转成-，/转成_]]
     * @param  {[type]} encoding    [编码，默认utf-8]
     * @return {[type]}             [解密后的字符串]
     */
    base64decode(str, urlFriendly, encoding){
        if(urlFriendly)
            str = str.replace(/\-/g, '+').replace(/_/g, '/')

        let buff = new Buffer(str, 'base64');

        if (encoding === 'buffer')
            return buff

        return buff.toString(encoding || 'utf8')
    }

    /**
     * [authCode 基于base64的加密/解密(目前有点问题，无法与php互通)]
     * @param  {[type]} str    [要加密的字符串]
     * @param  {[type]} mode   [操作类型，即加密还是解密，默认'decode']
     * @param  {[type]} expire [有效期，单位秒]
     * @param  {[type]} key    [混淆的key,如果不为空，则解密时必须提供]
     * @param  {[type]} level  [混淆等级，1～32，默认32，数值越大，加密后的字符串越长]
     * @return {[type]}        [加密/解密后的字符串]
     */
    authCode(str, mode, expire, key, level){
        if(typeof str !== 'string' && typeof str !== 'number')
            return str

        str += '';
        if(str === '')
            return str

        mode = mode || 'decode';
        expire = expire && (parseInt(Date.now()/1000) + expire) || '0000000000';
        level = level || 16;
        key = key || '';

        key = this.md5(key);

        let key1 = this.md5(key.slice(0, 16))
        let key2 = this.md5(key.slice(16))
        let key3

        if(level){
            if(mode === 'decode')
                key3 = str.slice(0, level)
            else
                key3 = this.randStr(16)
        }

        let mixKey = key1 + this.md5(key1 + key3);
        let mixKeyLen = mixKey.length;

        if(mode === 'decode')
            str = this.base64decode(str.slice(level))
        else
            str = expire + this.md5(str + key2).slice(0, 16) + str

        let strLen = str.length;

        let result = '';
        let ran = range(0, 255);
        let ranKey = [];

        for(let i = 0; i < 256; i++){
            ranKey.push(mixKey[i % mixKeyLen].charCodeAt(0))
        }

        

        for(let j = 0, i = 0; i < 256; i++){
            j = (j + ran[i] + ranKey[i]) % 256;
            let temp = ran[i];
            ran[i] = ran[j];
            ran[j] = temp;
        }

        for(let k = 0, j = 0, i = 0; i < strLen; i++){
            k = (k + 1) % 256;
            j = (j + ran[k]) % 256;
            let temp = ran[k];
            ran[k] = ran[j];
            ran[j] = temp;

            let code = str[i].charCodeAt() ^ ran[(ran[k] + ran[j]) % 256];
            result += String.fromCharCode(code);
        }

        if(mode === 'decode'){
            let res1 = result.slice(0, 10) - 0;
            let res2 = result.slice(10, 26);
            let res3 = this.md5(result.slice(26) + key2);
            let now = parseInt(Date.now()/1000);
            

            if((res1 == 0 || res1 - now > 0) && res2 == res3.slice(0, 16))
                return result.slice(26)
            else
                return ''
        }else{
            return key3 + this.base64encode(result).replace(/=/g, '')
        }
    }
}





module.exports = new Hash;